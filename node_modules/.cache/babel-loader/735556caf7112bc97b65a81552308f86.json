{"ast":null,"code":"import along from \"@turf/along\";\nimport circle from \"@turf/circle\";\nimport length from \"@turf/length\";\nimport { lineString } from \"@turf/helpers\";\nimport { isGeofenceArray, validateCoordinates } from \"./utils\";\nconst GEOFENCE_ID_REGEX = /^[-._\\p{L}\\p{N}]+$/iu;\nexport const getGeofenceFeatureArray = data => {\n  const coordinates = isGeofenceArray(data) ? data.map(geofence => geofence.geometry.polygon) : data;\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"MultiPolygon\",\n      coordinates\n    },\n    properties: {}\n  };\n};\nexport const getGeofenceFeatureFromPolygon = polygon => {\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n};\n// Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon\nexport const getPolygonFeatureFromBounds = (id, bounds) => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  });\n  // Gets coordinates 1/4 along the line from each coordinate\n  const southWestCoordinate = along(line, distanceInMiles / 4, {\n    units: \"miles\"\n  }).geometry.coordinates;\n  const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {\n    units: \"miles\"\n  }).geometry.coordinates;\n  // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate\n  const polygon = [[northeastCoordinate, [southWestCoordinate[0], northeastCoordinate[1]], southWestCoordinate, [northeastCoordinate[0], southWestCoordinate[1]], northeastCoordinate]];\n  return {\n    id,\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n};\nexport const getCircleFeatureFromCoords = (id, center, _ref) => {\n  let {\n    bounds,\n    radius\n  } = _ref;\n  if (!bounds && !radius) {\n    throw new Error(\"Circle requires a bounds or a radius\");\n  }\n  validateCoordinates(center);\n  const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;\n  const circleFeature = circle(center, circleRadius, {\n    units: \"miles\"\n  });\n  return {\n    id,\n    type: \"Feature\",\n    properties: {\n      isCircle: true,\n      center,\n      radius: circleRadius\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: circleFeature.geometry.coordinates\n    }\n  };\n};\nconst getDistanceFromBounds = bounds => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  return length(line, {\n    units: \"miles\"\n  });\n};\nexport const doesGeofenceExist = (id, loadedGeofences) => {\n  return !!loadedGeofences[id];\n};\nexport const isValidGeofenceId = id => {\n  return !!id.match(GEOFENCE_ID_REGEX);\n};\nexport const isExistingGeofenceId = (id, loadedGeofences) => {\n  return doesGeofenceExist(id, loadedGeofences);\n};\nexport const isGeofenceDisplayed = (id, displayedGeofences) => {\n  return !!displayedGeofences.find(geofence => geofence.geofenceId === id);\n};\nexport const getDistanceBetweenCoordinates = (startCoord, endCoord) => {\n  const line = lineString([startCoord, endCoord]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  });\n  return distanceInMiles;\n};","map":null,"metadata":{},"sourceType":"module"}