{"ast":null,"code":"import { useCallbackRef as e } from \"@radix-ui/react-use-callback-ref\";\nimport { Primitive as t } from \"@radix-ui/react-primitive\";\nimport { useComposedRefs as n } from \"@radix-ui/react-compose-refs\";\nimport * as o from \"react\";\nimport u from \"@babel/runtime/helpers/esm/extends\";\nconst c = {\n  bubbles: !1,\n  cancelable: !0\n};\nexport const FocusScope = /*#__PURE__*/o.forwardRef((i, f) => {\n  const {\n      loop: l = !1,\n      trapped: m = !1,\n      onMountAutoFocus: p,\n      onUnmountAutoFocus: v,\n      ...E\n    } = i,\n    [F, S] = o.useState(null),\n    b = e(p),\n    T = e(v),\n    y = o.useRef(null),\n    L = n(f, e => S(e)),\n    h = o.useRef({\n      paused: !1,\n      pause() {\n        this.paused = !0;\n      },\n      resume() {\n        this.paused = !1;\n      }\n    }).current;\n  o.useEffect(() => {\n    if (m) {\n      function e(e) {\n        if (h.paused || !F) return;\n        const t = e.target;\n        F.contains(t) ? y.current = t : a(y.current, {\n          select: !0\n        });\n      }\n      function t(e) {\n        !h.paused && F && (F.contains(e.relatedTarget) || a(y.current, {\n          select: !0\n        }));\n      }\n      return document.addEventListener(\"focusin\", e), document.addEventListener(\"focusout\", t), () => {\n        document.removeEventListener(\"focusin\", e), document.removeEventListener(\"focusout\", t);\n      };\n    }\n  }, [m, F, h.paused]), o.useEffect(() => {\n    if (F) {\n      d.add(h);\n      const t = document.activeElement;\n      if (!F.contains(t)) {\n        const n = new Event(\"focusScope.autoFocusOnMount\", c);\n        F.addEventListener(\"focusScope.autoFocusOnMount\", b), F.dispatchEvent(n), n.defaultPrevented || (!function (e) {\n          let {\n            select: t = !1\n          } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          const n = document.activeElement;\n          for (const o of e) if (a(o, {\n            select: t\n          }), document.activeElement !== n) return;\n        }((e = r(F), e.filter(e => \"A\" !== e.tagName)), {\n          select: !0\n        }), document.activeElement === t && a(F));\n      }\n      return () => {\n        F.removeEventListener(\"focusScope.autoFocusOnMount\", b), setTimeout(() => {\n          const e = new Event(\"focusScope.autoFocusOnUnmount\", c);\n          F.addEventListener(\"focusScope.autoFocusOnUnmount\", T), F.dispatchEvent(e), e.defaultPrevented || a(null != t ? t : document.body, {\n            select: !0\n          }), F.removeEventListener(\"focusScope.autoFocusOnUnmount\", T), d.remove(h);\n        }, 0);\n      };\n    }\n    var e;\n  }, [F, b, T, h]);\n  const N = o.useCallback(e => {\n    if (!l && !m) return;\n    if (h.paused) return;\n    const t = \"Tab\" === e.key && !e.altKey && !e.ctrlKey && !e.metaKey,\n      n = document.activeElement;\n    if (t && n) {\n      const t = e.currentTarget,\n        [o, u] = function (e) {\n          const t = r(e),\n            n = s(t, e),\n            o = s(t.reverse(), e);\n          return [n, o];\n        }(t);\n      o && u ? e.shiftKey || n !== u ? e.shiftKey && n === o && (e.preventDefault(), l && a(u, {\n        select: !0\n      })) : (e.preventDefault(), l && a(o, {\n        select: !0\n      })) : n === t && e.preventDefault();\n    }\n  }, [l, m, h.paused]); /*#__PURE__*/\n  return o.createElement(t.div, u({\n    tabIndex: -1\n  }, E, {\n    ref: L,\n    onKeyDown: N\n  }));\n}); /*#__PURE__*/\nfunction r(e) {\n  const t = [],\n    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: e => {\n        const t = \"INPUT\" === e.tagName && \"hidden\" === e.type;\n        return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      }\n    });\n  for (; n.nextNode();) t.push(n.currentNode);\n  return t;\n}\nfunction s(e, t) {\n  for (const n of e) if (!i(n, {\n    upTo: t\n  })) return n;\n}\nfunction i(e, _ref) {\n  let {\n    upTo: t\n  } = _ref;\n  if (\"hidden\" === getComputedStyle(e).visibility) return !0;\n  for (; e;) {\n    if (void 0 !== t && e === t) return !1;\n    if (\"none\" === getComputedStyle(e).display) return !0;\n    e = e.parentElement;\n  }\n  return !1;\n}\nfunction a(e) {\n  let {\n    select: t = !1\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (e && e.focus) {\n    const n = document.activeElement;\n    e.focus({\n      preventScroll: !0\n    }), e !== n && function (e) {\n      return e instanceof HTMLInputElement && \"select\" in e;\n    }(e) && t && e.select();\n  }\n}\nconst d = function () {\n  let e = [];\n  return {\n    add(t) {\n      const n = e[0];\n      t !== n && (null == n || n.pause()), e = f(e, t), e.unshift(t);\n    },\n    remove(t) {\n      var n;\n      e = f(e, t), null === (n = e[0]) || void 0 === n || n.resume();\n    }\n  };\n}();\nfunction f(e, t) {\n  const n = [...e],\n    o = n.indexOf(t);\n  return -1 !== o && n.splice(o, 1), n;\n}\nexport const Root = FocusScope;","map":null,"metadata":{},"sourceType":"module"}