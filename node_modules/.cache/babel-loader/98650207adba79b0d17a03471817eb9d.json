{"ast":null,"code":"import { useId as e } from \"@radix-ui/react-id\";\nimport { useFocusGuards as n } from \"@radix-ui/react-focus-guards\";\nimport { useCallbackRef as t } from \"@radix-ui/react-use-callback-ref\";\nimport { useDirection as r } from \"@radix-ui/react-use-direction\";\nimport * as o from \"@radix-ui/react-roving-focus\";\nimport { createRovingFocusGroupScope as u } from \"@radix-ui/react-roving-focus\";\nimport { Portal as c } from \"@radix-ui/react-portal\";\nimport * as a from \"@radix-ui/react-popper\";\nimport { createPopperScope as i } from \"@radix-ui/react-popper\";\nimport { Primitive as s } from \"@radix-ui/react-primitive\";\nimport { Presence as l } from \"@radix-ui/react-presence\";\nimport { FocusScope as d } from \"@radix-ui/react-focus-scope\";\nimport { DismissableLayer as p } from \"@radix-ui/react-dismissable-layer\";\nimport { createContextScope as f } from \"@radix-ui/react-context\";\nimport { useComposedRefs as m, composeRefs as v } from \"@radix-ui/react-compose-refs\";\nimport { createCollection as g } from \"@radix-ui/react-collection\";\nimport { composeEventHandlers as M } from \"@radix-ui/primitive\";\nimport { hideOthers as h } from \"aria-hidden\";\nimport { RemoveScroll as C } from \"react-remove-scroll\";\nimport * as E from \"react\";\nimport w from \"@babel/runtime/helpers/esm/extends\";\nconst x = [\"Enter\", \" \"],\n  b = [\"ArrowUp\", \"PageDown\", \"End\"],\n  R = [\"ArrowDown\", \"PageUp\", \"Home\", ...b],\n  _ = {\n    ltr: [...x, \"ArrowRight\"],\n    rtl: [...x, \"ArrowLeft\"]\n  },\n  y = {\n    ltr: [\"ArrowLeft\"],\n    rtl: [\"ArrowRight\"]\n  },\n  [I, k, P] = g(\"Menu\"),\n  [D, S] = f(\"Menu\", [P, i, u]);\nexport { S as createMenuScope };\nconst O = i(),\n  T = u(),\n  [L, A] = D(\"Menu\");\nexport const Menu = e => {\n  const {\n      __scopeMenu: n,\n      open: o = !1,\n      children: u,\n      onOpenChange: c,\n      modal: i = !0\n    } = e,\n    s = O(n),\n    [l, d] = E.useState(null),\n    p = E.useRef(!1),\n    f = t(c),\n    m = r(l, e.dir);\n  return E.useEffect(() => {\n    const e = () => {\n        p.current = !0, document.addEventListener(\"pointerdown\", n, {\n          capture: !0,\n          once: !0\n        }), document.addEventListener(\"pointermove\", n, {\n          capture: !0,\n          once: !0\n        });\n      },\n      n = () => p.current = !1;\n    return document.addEventListener(\"keydown\", e, {\n      capture: !0\n    }), () => {\n      document.removeEventListener(\"keydown\", e, {\n        capture: !0\n      }), document.removeEventListener(\"pointerdown\", n, {\n        capture: !0\n      }), document.removeEventListener(\"pointermove\", n, {\n        capture: !0\n      });\n    };\n  }, []), /*#__PURE__*/E.createElement(a.Root, s, /*#__PURE__*/E.createElement(L, {\n    scope: n,\n    isSubmenu: !1,\n    isUsingKeyboardRef: p,\n    dir: m,\n    open: o,\n    onOpenChange: f,\n    content: l,\n    onContentChange: d,\n    onRootClose: E.useCallback(() => f(!1), [f]),\n    modal: i\n  }, u));\n}; /*#__PURE__*/\nexport const MenuSub = n => {\n  const {\n      __scopeMenu: r,\n      children: o,\n      open: u = !1,\n      onOpenChange: c\n    } = n,\n    i = A(\"MenuSub\", r),\n    s = O(r),\n    [l, d] = E.useState(null),\n    [p, f] = E.useState(null),\n    m = t(c);\n  return E.useEffect(() => (!1 === i.open && m(!1), () => m(!1)), [i.open, m]), /*#__PURE__*/E.createElement(a.Root, s, /*#__PURE__*/E.createElement(L, {\n    scope: r,\n    isSubmenu: !0,\n    isUsingKeyboardRef: i.isUsingKeyboardRef,\n    dir: i.dir,\n    open: u,\n    onOpenChange: m,\n    content: p,\n    onContentChange: f,\n    onRootClose: i.onRootClose,\n    contentId: e(),\n    trigger: l,\n    onTriggerChange: d,\n    triggerId: e(),\n    modal: !1\n  }, o));\n}; /*#__PURE__*/\nexport const MenuAnchor = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      ...r\n    } = e,\n    o = O(t); /*#__PURE__*/\n  return E.createElement(a.Anchor, w({}, o, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nconst [F, K] = D(\"MenuContent\");\nexport const MenuContent = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      forceMount: t,\n      ...r\n    } = e,\n    o = A(\"MenuContent\", e.__scopeMenu); /*#__PURE__*/\n  return E.createElement(I.Provider, {\n    scope: e.__scopeMenu\n  }, /*#__PURE__*/E.createElement(l, {\n    present: t || o.open\n  }, /*#__PURE__*/E.createElement(I.Slot, {\n    scope: e.__scopeMenu\n  }, o.isSubmenu ? /*#__PURE__*/E.createElement(X, w({}, r, {\n    ref: n\n  })) : /*#__PURE__*/E.createElement(G, w({}, r, {\n    ref: n\n  })))));\n});\nconst G = /*#__PURE__*/E.forwardRef((e, n) => A(\"MenuContent\", e.__scopeMenu).modal ? /*#__PURE__*/E.createElement(U, w({}, e, {\n    ref: n\n  })) : /*#__PURE__*/E.createElement(V, w({}, e, {\n    ref: n\n  }))),\n  U = /*#__PURE__*/E.forwardRef((e, n) => {\n    const t = A(\"MenuContent\", e.__scopeMenu),\n      r = E.useRef(null),\n      o = m(n, r);\n    return E.useEffect(() => {\n      const e = r.current;\n      if (e) return h(e);\n    }, []), /*#__PURE__*/E.createElement(B, w({}, e, {\n      ref: o,\n      trapFocus: t.open,\n      disableOutsidePointerEvents: t.open,\n      disableOutsideScroll: !0,\n      onFocusOutside: M(e.onFocusOutside, e => e.preventDefault(), {\n        checkForDefaultPrevented: !1\n      }),\n      onDismiss: () => t.onOpenChange(!1)\n    }));\n  }),\n  V = /*#__PURE__*/E.forwardRef((e, n) => {\n    const t = A(\"MenuContent\", e.__scopeMenu); /*#__PURE__*/\n    return E.createElement(B, w({}, e, {\n      ref: n,\n      trapFocus: !1,\n      disableOutsidePointerEvents: !1,\n      disableOutsideScroll: !1,\n      onDismiss: () => t.onOpenChange(!1)\n    }));\n  }),\n  X = /*#__PURE__*/E.forwardRef((e, n) => {\n    const t = A(\"MenuContent\", e.__scopeMenu),\n      r = E.useRef(null),\n      o = m(n, r);\n    return t.isSubmenu ? /*#__PURE__*/E.createElement(B, w({\n      id: t.contentId,\n      \"aria-labelledby\": t.triggerId\n    }, e, {\n      ref: o,\n      align: \"start\",\n      side: \"rtl\" === t.dir ? \"left\" : \"right\",\n      portalled: !0,\n      disableOutsidePointerEvents: !1,\n      disableOutsideScroll: !1,\n      trapFocus: !1,\n      onOpenAutoFocus: e => {\n        var n;\n        t.isUsingKeyboardRef.current && (null === (n = r.current) || void 0 === n || n.focus()), e.preventDefault();\n      },\n      onCloseAutoFocus: e => e.preventDefault(),\n      onFocusOutside: M(e.onFocusOutside, e => {\n        e.target !== t.trigger && t.onOpenChange(!1);\n      }),\n      onEscapeKeyDown: M(e.onEscapeKeyDown, t.onRootClose),\n      onKeyDown: M(e.onKeyDown, e => {\n        const n = e.currentTarget.contains(e.target),\n          r = y[t.dir].includes(e.key);\n        var o;\n        n && r && (t.onOpenChange(!1), null === (o = t.trigger) || void 0 === o || o.focus(), e.preventDefault());\n      })\n    })) : null;\n  }),\n  B = /*#__PURE__*/E.forwardRef((e, t) => {\n    const {\n        __scopeMenu: r,\n        loop: u = !1,\n        trapFocus: i,\n        onOpenAutoFocus: s,\n        onCloseAutoFocus: l,\n        disableOutsidePointerEvents: f,\n        onEscapeKeyDown: v,\n        onPointerDownOutside: g,\n        onFocusOutside: h,\n        onInteractOutside: x,\n        onDismiss: _,\n        disableOutsideScroll: y,\n        allowPinchZoom: I,\n        portalled: P,\n        ...D\n      } = e,\n      S = A(\"MenuContent\", r),\n      L = O(r),\n      K = T(r),\n      G = k(r),\n      [U, V] = E.useState(null),\n      X = E.useRef(null),\n      B = m(t, X, S.onContentChange),\n      Y = E.useRef(0),\n      Z = E.useRef(\"\"),\n      z = E.useRef(0),\n      H = E.useRef(null),\n      W = E.useRef(\"right\"),\n      q = E.useRef(0),\n      N = P ? c : E.Fragment,\n      Q = y ? C : E.Fragment,\n      $ = y ? {\n        allowPinchZoom: I\n      } : void 0,\n      ee = e => {\n        var n, t;\n        const r = Z.current + e,\n          o = G().filter(e => !e.disabled),\n          u = document.activeElement,\n          c = null === (n = o.find(e => e.ref.current === u)) || void 0 === n ? void 0 : n.textValue,\n          a = function (e, n, t) {\n            const r = n.length > 1 && Array.from(n).every(e => e === n[0]) ? n[0] : n,\n              o = t ? e.indexOf(t) : -1;\n            let u = (c = e, a = Math.max(o, 0), c.map((e, n) => c[(a + n) % c.length]));\n            var c, a;\n            1 === r.length && (u = u.filter(e => e !== t));\n            const i = u.find(e => e.toLowerCase().startsWith(r.toLowerCase()));\n            return i !== t ? i : void 0;\n          }(o.map(e => e.textValue), r, c),\n          i = null === (t = o.find(e => e.textValue === a)) || void 0 === t ? void 0 : t.ref.current;\n        !function e(n) {\n          Z.current = n, window.clearTimeout(Y.current), \"\" !== n && (Y.current = window.setTimeout(() => e(\"\"), 1e3));\n        }(r), i && setTimeout(() => i.focus());\n      };\n    E.useEffect(() => () => window.clearTimeout(Y.current), []), n();\n    const ne = E.useCallback(e => {\n      var n, t;\n      return W.current === (null === (n = H.current) || void 0 === n ? void 0 : n.side) && function (e, n) {\n        if (!n) return !1;\n        return function (e, n) {\n          const {\n            x: t,\n            y: r\n          } = e;\n          let o = !1;\n          for (let e = 0, u = n.length - 1; e < n.length; u = e++) {\n            const c = n[e].x,\n              a = n[e].y,\n              i = n[u].x,\n              s = n[u].y;\n            a > r != s > r && t < (i - c) * (r - a) / (s - a) + c && (o = !o);\n          }\n          return o;\n        }({\n          x: e.clientX,\n          y: e.clientY\n        }, n);\n      }(e, null === (t = H.current) || void 0 === t ? void 0 : t.area);\n    }, []); /*#__PURE__*/\n    return E.createElement(N, null, /*#__PURE__*/E.createElement(Q, $, /*#__PURE__*/E.createElement(F, {\n      scope: r,\n      searchRef: Z,\n      onItemEnter: E.useCallback(e => {\n        ne(e) && e.preventDefault();\n      }, [ne]),\n      onItemLeave: E.useCallback(e => {\n        var n;\n        ne(e) || (null === (n = X.current) || void 0 === n || n.focus(), V(null));\n      }, [ne]),\n      onTriggerLeave: E.useCallback(e => {\n        ne(e) && e.preventDefault();\n      }, [ne]),\n      pointerGraceTimerRef: z,\n      onPointerGraceIntentChange: E.useCallback(e => {\n        H.current = e;\n      }, [])\n    }, /*#__PURE__*/E.createElement(d, {\n      asChild: !0,\n      trapped: i,\n      onMountAutoFocus: M(s, e => {\n        var n;\n        e.preventDefault(), null === (n = X.current) || void 0 === n || n.focus();\n      }),\n      onUnmountAutoFocus: l\n    }, /*#__PURE__*/E.createElement(p, {\n      asChild: !0,\n      disableOutsidePointerEvents: f,\n      onEscapeKeyDown: v,\n      onPointerDownOutside: g,\n      onFocusOutside: h,\n      onInteractOutside: x,\n      onDismiss: _\n    }, /*#__PURE__*/E.createElement(o.Root, w({\n      asChild: !0\n    }, K, {\n      dir: S.dir,\n      orientation: \"vertical\",\n      loop: u,\n      currentTabStopId: U,\n      onCurrentTabStopIdChange: V,\n      onEntryFocus: e => {\n        S.isUsingKeyboardRef.current || e.preventDefault();\n      }\n    }), /*#__PURE__*/E.createElement(a.Content, w({\n      role: \"menu\",\n      \"aria-orientation\": \"vertical\",\n      \"data-state\": j(S.open),\n      dir: S.dir\n    }, L, D, {\n      ref: B,\n      style: {\n        outline: \"none\",\n        ...D.style\n      },\n      onKeyDown: M(D.onKeyDown, e => {\n        const n = e.target,\n          t = e.currentTarget.contains(n),\n          r = e.ctrlKey || e.altKey || e.metaKey,\n          o = 1 === e.key.length;\n        t && (\"Tab\" === e.key && e.preventDefault(), !r && o && ee(e.key));\n        const u = X.current;\n        if (e.target !== u) return;\n        if (!R.includes(e.key)) return;\n        e.preventDefault();\n        const c = G().filter(e => !e.disabled).map(e => e.ref.current);\n        b.includes(e.key) && c.reverse(), function (e) {\n          const n = document.activeElement;\n          for (const t of e) {\n            if (t === n) return;\n            if (t.focus(), document.activeElement !== n) return;\n          }\n        }(c);\n      }),\n      onBlur: M(e.onBlur, e => {\n        e.currentTarget.contains(e.target) || (window.clearTimeout(Y.current), Z.current = \"\");\n      }),\n      onPointerMove: M(e.onPointerMove, J(e => {\n        const n = e.target,\n          t = q.current !== e.clientX;\n        if (e.currentTarget.contains(n) && t) {\n          const n = e.clientX > q.current ? \"right\" : \"left\";\n          W.current = n, q.current = e.clientX;\n        }\n      }))\n    }))))))));\n  });\nexport const MenuGroup = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    __scopeMenu: t,\n    ...r\n  } = e; /*#__PURE__*/\n  return E.createElement(s.div, w({\n    role: \"group\"\n  }, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const MenuLabel = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    __scopeMenu: t,\n    ...r\n  } = e; /*#__PURE__*/\n  return E.createElement(s.div, w({}, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const MenuItem = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      disabled: t = !1,\n      onSelect: r,\n      ...o\n    } = e,\n    u = E.useRef(null),\n    c = A(\"MenuItem\", e.__scopeMenu),\n    a = K(\"MenuItem\", e.__scopeMenu),\n    i = m(n, u),\n    s = E.useRef(!1); /*#__PURE__*/\n  return E.createElement(Y, w({}, o, {\n    ref: i,\n    disabled: t,\n    onClick: M(e.onClick, () => {\n      const e = u.current;\n      if (!t && e) {\n        const n = new Event(\"menu.itemSelect\", {\n          bubbles: !0,\n          cancelable: !0\n        });\n        e.addEventListener(\"menu.itemSelect\", e => null == r ? void 0 : r(e), {\n          once: !0\n        }), e.dispatchEvent(n), n.defaultPrevented ? s.current = !1 : c.onRootClose();\n      }\n    }),\n    onPointerDown: n => {\n      var t;\n      null === (t = e.onPointerDown) || void 0 === t || t.call(e, n), s.current = !0;\n    },\n    onPointerUp: M(e.onPointerUp, e => {\n      var n;\n      s.current || null === (n = e.currentTarget) || void 0 === n || n.click();\n    }),\n    onKeyDown: M(e.onKeyDown, e => {\n      const n = \"\" !== a.searchRef.current;\n      t || n && \" \" === e.key || x.includes(e.key) && (e.currentTarget.click(), e.preventDefault());\n    })\n  }));\n}); /*#__PURE__*/\nexport const MenuSubTrigger = /*#__PURE__*/E.forwardRef((e, n) => {\n  const t = A(\"MenuSubTrigger\", e.__scopeMenu),\n    r = K(\"MenuSubTrigger\", e.__scopeMenu),\n    o = E.useRef(null),\n    {\n      pointerGraceTimerRef: u,\n      onPointerGraceIntentChange: c\n    } = r,\n    a = {\n      __scopeMenu: e.__scopeMenu\n    },\n    i = E.useCallback(() => {\n      o.current && window.clearTimeout(o.current), o.current = null;\n    }, []);\n  return E.useEffect(() => i, [i]), E.useEffect(() => {\n    const e = u.current;\n    return () => {\n      window.clearTimeout(e), c(null);\n    };\n  }, [u, c]), t.isSubmenu ? /*#__PURE__*/E.createElement(MenuAnchor, w({\n    asChild: !0\n  }, a), /*#__PURE__*/E.createElement(Y, w({\n    id: t.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": t.open,\n    \"aria-controls\": t.contentId,\n    \"data-state\": j(t.open)\n  }, e, {\n    ref: v(n, t.onTriggerChange),\n    onClick: n => {\n      var r;\n      null === (r = e.onClick) || void 0 === r || r.call(e, n), e.disabled || n.defaultPrevented || (n.currentTarget.focus(), t.open || t.onOpenChange(!0));\n    },\n    onPointerMove: M(e.onPointerMove, J(n => {\n      r.onItemEnter(n), n.defaultPrevented || e.disabled || t.open || o.current || (r.onPointerGraceIntentChange(null), o.current = window.setTimeout(() => {\n        t.onOpenChange(!0), i();\n      }, 100));\n    })),\n    onPointerLeave: M(e.onPointerLeave, J(e => {\n      var n;\n      i();\n      const o = null === (n = t.content) || void 0 === n ? void 0 : n.getBoundingClientRect();\n      if (o) {\n        var c;\n        const n = null === (c = t.content) || void 0 === c ? void 0 : c.dataset.side,\n          a = \"right\" === n,\n          i = a ? -5 : 5,\n          s = o[a ? \"left\" : \"right\"],\n          l = o[a ? \"right\" : \"left\"];\n        r.onPointerGraceIntentChange({\n          area: [{\n            x: e.clientX + i,\n            y: e.clientY\n          }, {\n            x: s,\n            y: o.top\n          }, {\n            x: l,\n            y: o.top\n          }, {\n            x: l,\n            y: o.bottom\n          }, {\n            x: s,\n            y: o.bottom\n          }],\n          side: n\n        }), window.clearTimeout(u.current), u.current = window.setTimeout(() => r.onPointerGraceIntentChange(null), 300);\n      } else {\n        if (r.onTriggerLeave(e), e.defaultPrevented) return;\n        r.onPointerGraceIntentChange(null);\n      }\n    })),\n    onKeyDown: M(e.onKeyDown, n => {\n      const o = \"\" !== r.searchRef.current;\n      var u;\n      e.disabled || o && \" \" === n.key || _[t.dir].includes(n.key) && (t.onOpenChange(!0), null === (u = t.content) || void 0 === u || u.focus(), n.preventDefault());\n    })\n  }))) : null;\n}); /*#__PURE__*/\nconst Y = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      disabled: r = !1,\n      textValue: u,\n      ...c\n    } = e,\n    a = K(\"MenuItem\", t),\n    i = T(t),\n    l = E.useRef(null),\n    d = m(n, l),\n    [p, f] = E.useState(\"\");\n  return E.useEffect(() => {\n    const e = l.current;\n    var n;\n    e && f((null !== (n = e.textContent) && void 0 !== n ? n : \"\").trim());\n  }, [c.children]), /*#__PURE__*/E.createElement(I.ItemSlot, {\n    scope: t,\n    disabled: r,\n    textValue: null != u ? u : p\n  }, /*#__PURE__*/E.createElement(o.Item, w({\n    asChild: !0\n  }, i, {\n    focusable: !r\n  }), /*#__PURE__*/E.createElement(s.div, w({\n    role: \"menuitem\",\n    \"aria-disabled\": r || void 0,\n    \"data-disabled\": r ? \"\" : void 0\n  }, c, {\n    ref: d,\n    onPointerMove: M(e.onPointerMove, J(e => {\n      if (r) a.onItemLeave(e);else if (a.onItemEnter(e), !e.defaultPrevented) {\n        e.currentTarget.focus();\n      }\n    })),\n    onPointerLeave: M(e.onPointerLeave, J(e => a.onItemLeave(e)))\n  }))));\n});\nexport const MenuCheckboxItem = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    checked: t = !1,\n    onCheckedChange: r,\n    ...o\n  } = e; /*#__PURE__*/\n  return E.createElement(H, {\n    scope: e.__scopeMenu,\n    checked: t\n  }, /*#__PURE__*/E.createElement(MenuItem, w({\n    role: \"menuitemcheckbox\",\n    \"aria-checked\": t\n  }, o, {\n    ref: n,\n    \"data-state\": q(t),\n    onSelect: M(o.onSelect, () => null == r ? void 0 : r(!t), {\n      checkForDefaultPrevented: !1\n    })\n  })));\n}); /*#__PURE__*/\nconst [Z, z] = D(\"MenuRadioGroup\", {\n  value: void 0,\n  onValueChange: () => {}\n});\nexport const MenuRadioGroup = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      value: r,\n      onValueChange: o,\n      ...u\n    } = e,\n    c = t(o); /*#__PURE__*/\n  return E.createElement(Z, {\n    scope: e.__scopeMenu,\n    value: r,\n    onValueChange: c\n  }, /*#__PURE__*/E.createElement(MenuGroup, w({}, u, {\n    ref: n\n  })));\n}); /*#__PURE__*/\nexport const MenuRadioItem = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      value: t,\n      ...r\n    } = e,\n    o = z(\"MenuRadioItem\", e.__scopeMenu),\n    u = t === o.value; /*#__PURE__*/\n  return E.createElement(H, {\n    scope: e.__scopeMenu,\n    checked: u\n  }, /*#__PURE__*/E.createElement(MenuItem, w({\n    role: \"menuitemradio\",\n    \"aria-checked\": u\n  }, r, {\n    ref: n,\n    \"data-state\": q(u),\n    onSelect: M(r.onSelect, () => {\n      var e;\n      return null === (e = o.onValueChange) || void 0 === e ? void 0 : e.call(o, t);\n    }, {\n      checkForDefaultPrevented: !1\n    })\n  })));\n}); /*#__PURE__*/\nconst [H, W] = D(\"MenuItemIndicator\", {\n  checked: !1\n});\nexport const MenuItemIndicator = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      forceMount: r,\n      ...o\n    } = e,\n    u = W(\"MenuItemIndicator\", t); /*#__PURE__*/\n  return E.createElement(l, {\n    present: r || u.checked\n  }, /*#__PURE__*/E.createElement(s.span, w({}, o, {\n    ref: n,\n    \"data-state\": q(u.checked)\n  })));\n}); /*#__PURE__*/\nexport const MenuSeparator = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    __scopeMenu: t,\n    ...r\n  } = e; /*#__PURE__*/\n  return E.createElement(s.div, w({\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\"\n  }, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const MenuArrow = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      ...r\n    } = e,\n    o = O(t); /*#__PURE__*/\n  return E.createElement(a.Arrow, w({}, o, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nfunction j(e) {\n  return e ? \"open\" : \"closed\";\n}\nfunction q(e) {\n  return e ? \"checked\" : \"unchecked\";\n}\nfunction J(e) {\n  return n => \"mouse\" === n.pointerType ? e(n) : void 0;\n}\nexport const Root = Menu;\nexport const Sub = MenuSub;\nexport const Anchor = MenuAnchor;\nexport const SubTrigger = MenuSubTrigger;\nexport const Content = MenuContent;\nexport const Group = MenuGroup;\nexport const Label = MenuLabel;\nexport const Item = MenuItem;\nexport const CheckboxItem = MenuCheckboxItem;\nexport const RadioGroup = MenuRadioGroup;\nexport const RadioItem = MenuRadioItem;\nexport const ItemIndicator = MenuItemIndicator;\nexport const Separator = MenuSeparator;\nexport const Arrow = MenuArrow;","map":null,"metadata":{},"sourceType":"module"}