{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { CognitoJwtInvalidClientIdError, CognitoJwtInvalidGroupError, CognitoJwtInvalidTokenUseError, JwtInvalidClaimError, ParameterValidationError } from \"./error.js\";\nimport { JwtRsaVerifierBase } from \"./jwt-rsa.js\";\nimport { assertStringArrayContainsString, assertStringEquals, assertStringArraysOverlap } from \"./assert.js\";\n/**\n * Validate claims of a decoded Cognito JWT.\n * This function throws an error in case there's any validation issue.\n *\n * @param payload - The JSON parsed payload of the Cognito JWT\n * @param options - Validation options\n * @param options.groups - The cognito groups, of which at least one must be present in the JWT's cognito:groups claim\n * @param options.tokenUse - The required token use of the JWT: \"id\" or \"access\"\n * @param options.clientId - The required clientId of the JWT. May be an array of string, of which at least one must match\n * @returns void\n */\nexport function validateCognitoJwtFields(payload, options) {\n  // Check groups\n  if (options.groups != null) {\n    assertStringArraysOverlap(\"Cognito group\", payload[\"cognito:groups\"], options.groups, CognitoJwtInvalidGroupError);\n  }\n  // Check token use\n  assertStringArrayContainsString(\"Token use\", payload.token_use, [\"id\", \"access\"], CognitoJwtInvalidTokenUseError);\n  if (options.tokenUse !== null) {\n    if (options.tokenUse === undefined) {\n      throw new ParameterValidationError(\"tokenUse must be provided or set to null explicitly\");\n    }\n    assertStringEquals(\"Token use\", payload.token_use, options.tokenUse, CognitoJwtInvalidTokenUseError);\n  }\n  // Check clientId aka audience\n  if (options.clientId !== null) {\n    if (options.clientId === undefined) {\n      throw new ParameterValidationError(\"clientId must be provided or set to null explicitly\");\n    }\n    if (payload.token_use === \"id\") {\n      assertStringArrayContainsString('Client ID (\"audience\")', payload.aud, options.clientId, CognitoJwtInvalidClientIdError);\n    } else {\n      assertStringArrayContainsString(\"Client ID\", payload.client_id, options.clientId, CognitoJwtInvalidClientIdError);\n    }\n  }\n}\n/**\n * Class representing a verifier for JWTs signed by Amazon Cognito\n */\nexport class CognitoJwtVerifier extends JwtRsaVerifierBase {\n  constructor(props, jwksCache) {\n    const issuerConfig = Array.isArray(props) ? props.map(p => ({\n      ...p,\n      ...CognitoJwtVerifier.parseUserPoolId(p.userPoolId),\n      audience: null // checked instead by validateCognitoJwtFields\n    })) : {\n      ...props,\n      ...CognitoJwtVerifier.parseUserPoolId(props.userPoolId),\n      audience: null // checked instead by validateCognitoJwtFields\n    };\n\n    super(issuerConfig, jwksCache);\n  }\n  /**\n   * Parse a User Pool ID, to extract the issuer and JWKS URI\n   *\n   * @param userPoolId The User Pool ID\n   * @returns The issuer and JWKS URI for the User Pool\n   */\n  static parseUserPoolId(userPoolId) {\n    // Disable safe regexp check as userPoolId is provided by developer, i.e. is not user input\n    // eslint-disable-next-line security/detect-unsafe-regex\n    const match = userPoolId.match(/^(?<region>(\\w+-)?\\w+-\\w+-\\d)+_\\w+$/);\n    if (!match) {\n      throw new ParameterValidationError(`Invalid Cognito User Pool ID: ${userPoolId}`);\n    }\n    const region = match.groups.region;\n    const issuer = `https://cognito-idp.${region}.amazonaws.com/${userPoolId}`;\n    return {\n      issuer,\n      jwksUri: `${issuer}/.well-known/jwks.json`\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  static create(verifyProperties, additionalProperties) {\n    return new this(verifyProperties, additionalProperties?.jwksCache);\n  }\n  /**\n   * Verify (synchronously) a JWT that is signed by Amazon Cognito.\n   *\n   * @param jwt The JWT, as string\n   * @param props Verification properties\n   * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown\n   */\n  verifySync() {\n    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {\n      _ref[_key] = arguments[_key];\n    }\n    let [jwt, properties] = _ref;\n    const {\n      decomposedJwt,\n      jwksUri,\n      verifyProperties\n    } = this.getVerifyParameters(jwt, properties);\n    this.verifyDecomposedJwtSync(decomposedJwt, jwksUri, verifyProperties);\n    try {\n      validateCognitoJwtFields(decomposedJwt.payload, verifyProperties);\n    } catch (err) {\n      if (verifyProperties.includeRawJwtInErrors && err instanceof JwtInvalidClaimError) {\n        throw err.withRawJwt(decomposedJwt);\n      }\n      throw err;\n    }\n    return decomposedJwt.payload;\n  }\n  /**\n   * Verify (asynchronously) a JWT that is signed by Amazon Cognito.\n   * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,\n   * in case it is not yet available in the cache.\n   *\n   * @param jwt The JWT, as string\n   * @param props Verification properties\n   * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects\n   */\n  async verify() {\n    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      _ref2[_key2] = arguments[_key2];\n    }\n    let [jwt, properties] = _ref2;\n    const {\n      decomposedJwt,\n      jwksUri,\n      verifyProperties\n    } = this.getVerifyParameters(jwt, properties);\n    await this.verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties);\n    try {\n      validateCognitoJwtFields(decomposedJwt.payload, verifyProperties);\n    } catch (err) {\n      if (verifyProperties.includeRawJwtInErrors && err instanceof JwtInvalidClaimError) {\n        throw err.withRawJwt(decomposedJwt);\n      }\n      throw err;\n    }\n    return decomposedJwt.payload;\n  }\n  /**\n   * This method loads a JWKS that you provide, into the JWKS cache, so that it is\n   * available for JWT verification. Use this method to speed up the first JWT verification\n   * (when the JWKS would otherwise have to be downloaded from the JWKS uri), or to provide the JWKS\n   * in case the JwtVerifier does not have internet access to download the JWKS\n   *\n   * @param jwks The JWKS\n   * @param userPoolId The userPoolId for which you want to cache the JWKS\n   *  Supply this field, if you instantiated the CognitoJwtVerifier with multiple userPoolIds\n   * @returns void\n   */\n  cacheJwks() {\n    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      _ref3[_key3] = arguments[_key3];\n    }\n    let [jwks, userPoolId] = _ref3;\n    let issuer;\n    if (userPoolId !== undefined) {\n      issuer = CognitoJwtVerifier.parseUserPoolId(userPoolId).issuer;\n    } else if (this.expectedIssuers.length > 1) {\n      throw new ParameterValidationError(\"userPoolId must be provided\");\n    }\n    const issuerConfig = this.getIssuerConfig(issuer);\n    super.cacheJwks(jwks, issuerConfig.issuer);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}