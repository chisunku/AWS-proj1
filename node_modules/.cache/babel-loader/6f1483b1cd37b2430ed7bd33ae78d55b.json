{"ast":null,"code":"import { __asyncGenerator, __await, __generator } from \"tslib\";\nexport function getChunkedStream(source) {\n  var _a;\n  var currentMessageTotalLength = 0;\n  var currentMessagePendingLength = 0;\n  var currentMessage = null;\n  var messageLengthBuffer = null;\n  var allocateMessage = function (size) {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    var currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  var iterator = function () {\n    return __asyncGenerator(this, arguments, function () {\n      var sourceIterator, _a, value, done, chunkLength, currentOffset, bytesRemaining, numBytesForTotal, numBytesToWrite;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            sourceIterator = source[Symbol.asyncIterator]();\n            _b.label = 1;\n          case 1:\n            if (!true) return [3 /*break*/, 16];\n            return [4 /*yield*/, __await(sourceIterator.next())];\n          case 2:\n            _a = _b.sent(), value = _a.value, done = _a.done;\n            if (!done) return [3 /*break*/, 10];\n            if (!!currentMessageTotalLength) return [3 /*break*/, 4];\n            return [4 /*yield*/, __await(void 0)];\n          case 3:\n            return [2 /*return*/, _b.sent()];\n          case 4:\n            if (!(currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 7];\n            return [4 /*yield*/, __await(currentMessage)];\n          case 5:\n            return [4 /*yield*/, _b.sent()];\n          case 6:\n            _b.sent();\n            return [3 /*break*/, 8];\n          case 7:\n            throw new Error(\"Truncated event message received.\");\n          case 8:\n            return [4 /*yield*/, __await(void 0)];\n          case 9:\n            return [2 /*return*/, _b.sent()];\n          case 10:\n            chunkLength = value.length;\n            currentOffset = 0;\n            _b.label = 11;\n          case 11:\n            if (!(currentOffset < chunkLength)) return [3 /*break*/, 15];\n            // create new message if necessary\n            if (!currentMessage) {\n              bytesRemaining = chunkLength - currentOffset;\n              // prevent edge case where total length spans 2 chunks\n              if (!messageLengthBuffer) {\n                messageLengthBuffer = new Uint8Array(4);\n              }\n              numBytesForTotal = Math.min(4 - currentMessagePendingLength,\n              // remaining bytes to fill the messageLengthBuffer\n              bytesRemaining // bytes left in chunk\n              );\n\n              messageLengthBuffer.set(\n              // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n              value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n              currentMessagePendingLength += numBytesForTotal;\n              currentOffset += numBytesForTotal;\n              if (currentMessagePendingLength < 4) {\n                // not enough information to create the current message\n                return [3 /*break*/, 15];\n              }\n              allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n              messageLengthBuffer = null;\n            }\n            numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength,\n            // number of bytes left to complete message\n            chunkLength - currentOffset // number of bytes left in the original chunk\n            );\n\n            currentMessage.set(\n            // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n            value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesToWrite;\n            currentOffset += numBytesToWrite;\n            if (!(currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 14];\n            return [4 /*yield*/, __await(currentMessage)];\n          case 12:\n            // push out the message\n            return [4 /*yield*/, _b.sent()];\n          case 13:\n            // push out the message\n            _b.sent();\n            // cleanup\n            currentMessage = null;\n            currentMessageTotalLength = 0;\n            currentMessagePendingLength = 0;\n            _b.label = 14;\n          case 14:\n            return [3 /*break*/, 11];\n          case 15:\n            return [3 /*break*/, 1];\n          case 16:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return _a = {}, _a[Symbol.asyncIterator] = iterator, _a;\n}","map":null,"metadata":{},"sourceType":"module"}