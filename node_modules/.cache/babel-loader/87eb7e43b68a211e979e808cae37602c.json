{"ast":null,"code":"import { createCollection as e } from \"@radix-ui/react-collection\";\nimport { Primitive as t } from \"@radix-ui/react-primitive\";\nimport { useSize as n } from \"@radix-ui/react-use-size\";\nimport { usePrevious as r } from \"@radix-ui/react-use-previous\";\nimport { useDirection as o } from \"@radix-ui/react-use-direction\";\nimport { useControllableState as i } from \"@radix-ui/react-use-controllable-state\";\nimport { createContextScope as a } from \"@radix-ui/react-context\";\nimport { useComposedRefs as l } from \"@radix-ui/react-compose-refs\";\nimport { composeEventHandlers as d } from \"@radix-ui/primitive\";\nimport { clamp as s } from \"@radix-ui/number\";\nimport * as u from \"react\";\nimport c from \"@babel/runtime/helpers/esm/extends\";\nconst m = [\"PageUp\", \"PageDown\"],\n  f = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"],\n  p = {\n    ltr: [\"ArrowDown\", \"Home\", \"ArrowLeft\", \"PageDown\"],\n    rtl: [\"ArrowDown\", \"Home\", \"ArrowRight\", \"PageDown\"]\n  },\n  [S, h, v] = e(\"Slider\"),\n  [w, g] = a(\"Slider\", [v]);\nexport { g as createSliderScope };\nconst [x, b] = w(\"Slider\");\nexport const Slider = /*#__PURE__*/u.forwardRef((e, t) => {\n  const {\n      name: n,\n      min: r = 0,\n      max: o = 100,\n      step: a = 1,\n      orientation: d = \"horizontal\",\n      disabled: p = !1,\n      minStepsBetweenThumbs: h = 0,\n      defaultValue: v = [r],\n      value: w,\n      onValueChange: g = () => {},\n      ...b\n    } = e,\n    [E, y] = u.useState(null),\n    _ = l(t, e => y(e)),\n    M = u.useRef(new Set()),\n    K = u.useRef(0),\n    T = \"horizontal\" === d,\n    k = !E || Boolean(E.closest(\"form\")),\n    C = T ? R : D,\n    [I = [], z] = i({\n      prop: w,\n      defaultProp: v,\n      onChange: e => {\n        var t;\n        null === (t = [...M.current][K.current]) || void 0 === t || t.focus(), g(e);\n      }\n    });\n  function A(e, t) {\n    const n = function (e) {\n        return (String(e).split(\".\")[1] || \"\").length;\n      }(a),\n      i = function (e, t) {\n        const n = Math.pow(10, t);\n        return Math.round(e * n) / n;\n      }(Math.round((e - r) / a) * a + r, n),\n      l = s(i, [r, o]);\n    z(function () {\n      let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      const n = function () {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let t = arguments.length > 1 ? arguments[1] : undefined;\n        let n = arguments.length > 2 ? arguments[2] : undefined;\n        const r = [...e];\n        return r[n] = t, r.sort((e, t) => e - t);\n      }(e, l, t);\n      return function (e, t) {\n        if (t > 0) {\n          const n = function (e) {\n            return e.slice(0, -1).map((t, n) => e[n + 1] - t);\n          }(e);\n          return Math.min(...n) >= t;\n        }\n        return !0;\n      }(n, h * a) ? (K.current = n.indexOf(l), String(n) === String(e) ? e : n) : e;\n    });\n  } /*#__PURE__*/\n  return u.createElement(x, {\n    scope: e.__scopeSlider,\n    disabled: p,\n    min: r,\n    max: o,\n    valueIndexToChangeRef: K,\n    thumbs: M.current,\n    values: I,\n    orientation: d\n  }, /*#__PURE__*/u.createElement(S.Provider, {\n    scope: e.__scopeSlider\n  }, /*#__PURE__*/u.createElement(S.Slot, {\n    scope: e.__scopeSlider\n  }, /*#__PURE__*/u.createElement(C, c({\n    \"aria-disabled\": p,\n    \"data-disabled\": p ? \"\" : void 0\n  }, b, {\n    ref: _,\n    min: r,\n    max: o,\n    onSlideStart: p ? void 0 : function (e) {\n      A(e, function (e, t) {\n        if (1 === e.length) return 0;\n        const n = e.map(e => Math.abs(e - t)),\n          r = Math.min(...n);\n        return n.indexOf(r);\n      }(I, e));\n    },\n    onSlideMove: p ? void 0 : function (e) {\n      A(e, K.current);\n    },\n    onHomeKeyDown: () => !p && A(r, 0),\n    onEndKeyDown: () => !p && A(o, I.length - 1),\n    onStepKeyDown: _ref => {\n      let {\n        event: e,\n        direction: t\n      } = _ref;\n      if (!p) {\n        const n = m.includes(e.key) || e.shiftKey && f.includes(e.key) ? 10 : 1,\n          r = K.current;\n        A(I[r] + a * n * t, r);\n      }\n    }\n  })))), k && I.map((e, t) => /*#__PURE__*/u.createElement(P, {\n    key: t,\n    name: n ? n + (I.length > 1 ? \"[]\" : \"\") : void 0,\n    value: e\n  })));\n}); /*#__PURE__*/\nconst [E, y] = w(\"Slider\", {\n    startEdge: \"left\",\n    endEdge: \"right\",\n    size: \"width\",\n    direction: 1\n  }),\n  R = /*#__PURE__*/u.forwardRef((e, t) => {\n    const {\n        min: n,\n        max: r,\n        dir: i,\n        onSlideStart: a,\n        onSlideMove: d,\n        onStepKeyDown: s,\n        ...m\n      } = e,\n      [f, S] = u.useState(null),\n      h = l(t, e => S(e)),\n      v = u.useRef(),\n      w = o(f, i),\n      g = \"ltr\" === w;\n    function x(e) {\n      const t = v.current || f.getBoundingClientRect(),\n        o = T([0, t.width], g ? [n, r] : [r, n]);\n      return v.current = t, o(e - t.left);\n    } /*#__PURE__*/\n    return u.createElement(E, {\n      scope: e.__scopeSlider,\n      startEdge: g ? \"left\" : \"right\",\n      endEdge: g ? \"right\" : \"left\",\n      direction: g ? 1 : -1,\n      size: \"width\"\n    }, /*#__PURE__*/u.createElement(_, c({\n      \"data-orientation\": \"horizontal\"\n    }, m, {\n      ref: h,\n      style: {\n        ...m.style,\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      },\n      onSlideStart: e => {\n        const t = x(e.clientX);\n        null == a || a(t);\n      },\n      onSlideMove: e => {\n        const t = x(e.clientX);\n        null == d || d(t);\n      },\n      onSlideEnd: () => v.current = void 0,\n      onStepKeyDown: e => {\n        const t = p[w].includes(e.key);\n        null == s || s({\n          event: e,\n          direction: t ? -1 : 1\n        });\n      }\n    })));\n  }),\n  D = /*#__PURE__*/u.forwardRef((e, t) => {\n    const {\n        min: n,\n        max: r,\n        onSlideStart: o,\n        onSlideMove: i,\n        onStepKeyDown: a,\n        ...d\n      } = e,\n      s = u.useRef(null),\n      m = l(t, s),\n      f = u.useRef();\n    function S(e) {\n      const t = f.current || s.current.getBoundingClientRect(),\n        o = T([0, t.height], [r, n]);\n      return f.current = t, o(e - t.top);\n    } /*#__PURE__*/\n    return u.createElement(E, {\n      scope: e.__scopeSlider,\n      startEdge: \"bottom\",\n      endEdge: \"top\",\n      size: \"height\",\n      direction: 1\n    }, /*#__PURE__*/u.createElement(_, c({\n      \"data-orientation\": \"vertical\"\n    }, d, {\n      ref: m,\n      style: {\n        ...d.style,\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      },\n      onSlideStart: e => {\n        const t = S(e.clientY);\n        null == o || o(t);\n      },\n      onSlideMove: e => {\n        const t = S(e.clientY);\n        null == i || i(t);\n      },\n      onSlideEnd: () => f.current = void 0,\n      onStepKeyDown: e => {\n        const t = p.ltr.includes(e.key);\n        null == a || a({\n          event: e,\n          direction: t ? -1 : 1\n        });\n      }\n    })));\n  }),\n  _ = /*#__PURE__*/u.forwardRef((e, n) => {\n    const {\n        __scopeSlider: r,\n        onSlideStart: o,\n        onSlideMove: i,\n        onSlideEnd: a,\n        onHomeKeyDown: l,\n        onEndKeyDown: s,\n        onStepKeyDown: p,\n        ...S\n      } = e,\n      h = b(\"Slider\", r); /*#__PURE__*/\n    return u.createElement(t.span, c({}, S, {\n      ref: n,\n      onKeyDown: d(e.onKeyDown, e => {\n        \"Home\" === e.key ? (l(e), e.preventDefault()) : \"End\" === e.key ? (s(e), e.preventDefault()) : m.concat(f).includes(e.key) && (p(e), e.preventDefault());\n      }),\n      onPointerDown: d(e.onPointerDown, e => {\n        const t = e.target;\n        t.setPointerCapture(e.pointerId), e.preventDefault(), h.thumbs.has(t) ? t.focus() : o(e);\n      }),\n      onPointerMove: d(e.onPointerMove, e => {\n        e.target.hasPointerCapture(e.pointerId) && i(e);\n      }),\n      onPointerUp: d(e.onPointerUp, e => {\n        const t = e.target;\n        t.hasPointerCapture(e.pointerId) && (t.releasePointerCapture(e.pointerId), a(e));\n      })\n    }));\n  });\nexport const SliderTrack = /*#__PURE__*/u.forwardRef((e, n) => {\n  const {\n      __scopeSlider: r,\n      ...o\n    } = e,\n    i = b(\"SliderTrack\", r); /*#__PURE__*/\n  return u.createElement(t.span, c({\n    \"data-disabled\": i.disabled ? \"\" : void 0,\n    \"data-orientation\": i.orientation\n  }, o, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const SliderRange = /*#__PURE__*/u.forwardRef((e, n) => {\n  const {\n      __scopeSlider: r,\n      ...o\n    } = e,\n    i = b(\"SliderRange\", r),\n    a = y(\"SliderRange\", r),\n    d = u.useRef(null),\n    s = l(n, d),\n    m = i.values.length,\n    f = i.values.map(e => K(e, i.min, i.max)),\n    p = m > 1 ? Math.min(...f) : 0,\n    S = 100 - Math.max(...f); /*#__PURE__*/\n  return u.createElement(t.span, c({\n    \"data-orientation\": i.orientation,\n    \"data-disabled\": i.disabled ? \"\" : void 0\n  }, o, {\n    ref: s,\n    style: {\n      ...e.style,\n      [a.startEdge]: p + \"%\",\n      [a.endEdge]: S + \"%\"\n    }\n  }));\n}); /*#__PURE__*/\nexport const SliderThumb = /*#__PURE__*/u.forwardRef((e, t) => {\n  const n = h(e.__scopeSlider),\n    [r, o] = u.useState(null),\n    i = l(t, e => o(e)),\n    a = u.useMemo(() => r ? n().findIndex(e => e.ref.current === r) : -1, [n, r]); /*#__PURE__*/\n  return u.createElement(M, c({}, e, {\n    ref: i,\n    index: a\n  }));\n});\nconst M = /*#__PURE__*/u.forwardRef((e, r) => {\n    const {\n        __scopeSlider: o,\n        index: i,\n        ...a\n      } = e,\n      s = b(\"SliderThumb\", o),\n      m = y(\"SliderThumb\", o),\n      [f, p] = u.useState(null),\n      h = l(r, e => p(e)),\n      v = n(f),\n      w = s.values[i],\n      g = void 0 === w ? 0 : K(w, s.min, s.max),\n      x = function (e, t) {\n        return t > 2 ? `Value ${e + 1} of ${t}` : 2 === t ? [\"Minimum\", \"Maximum\"][e] : void 0;\n      }(i, s.values.length),\n      E = null == v ? void 0 : v[m.size],\n      R = E ? function (e, t, n) {\n        const r = e / 2,\n          o = T([0, 50], [0, r]);\n        return (r - o(t) * n) * n;\n      }(E, g, m.direction) : 0;\n    return u.useEffect(() => {\n      if (f) return s.thumbs.add(f), () => {\n        s.thumbs.delete(f);\n      };\n    }, [f, s.thumbs]), /*#__PURE__*/u.createElement(\"span\", {\n      style: {\n        transform: \"var(--radix-slider-thumb-transform)\",\n        position: \"absolute\",\n        [m.startEdge]: `calc(${g}% + ${R}px)`\n      }\n    }, /*#__PURE__*/u.createElement(S.ItemSlot, {\n      scope: e.__scopeSlider\n    }, /*#__PURE__*/u.createElement(t.span, c({\n      role: \"slider\",\n      \"aria-label\": e[\"aria-label\"] || x,\n      \"aria-valuemin\": s.min,\n      \"aria-valuenow\": w,\n      \"aria-valuemax\": s.max,\n      \"aria-orientation\": s.orientation,\n      \"data-orientation\": s.orientation,\n      \"data-disabled\": s.disabled ? \"\" : void 0,\n      tabIndex: s.disabled ? void 0 : 0\n    }, a, {\n      ref: h,\n      style: void 0 === w ? {\n        display: \"none\"\n      } : e.style,\n      onFocus: d(e.onFocus, () => {\n        s.valueIndexToChangeRef.current = i;\n      })\n    }))));\n  }),\n  P = e => {\n    const {\n        value: t,\n        ...n\n      } = e,\n      o = u.useRef(null),\n      i = r(t);\n    return u.useEffect(() => {\n      const e = o.current,\n        n = window.HTMLInputElement.prototype,\n        r = Object.getOwnPropertyDescriptor(n, \"value\").set;\n      if (i !== t && r) {\n        const n = new Event(\"input\", {\n          bubbles: !0\n        });\n        r.call(e, t), e.dispatchEvent(n);\n      }\n    }, [i, t]), /*#__PURE__*/u.createElement(\"input\", c({\n      style: {\n        display: \"none\"\n      }\n    }, n, {\n      ref: o,\n      defaultValue: t\n    }));\n  }; /*#__PURE__*/\nfunction K(e, t, n) {\n  return 100 / (n - t) * (e - t);\n}\nfunction T(e, t) {\n  return n => {\n    if (e[0] === e[1] || t[0] === t[1]) return t[0];\n    const r = (t[1] - t[0]) / (e[1] - e[0]);\n    return t[0] + r * (n - e[0]);\n  };\n}\nexport const Root = Slider;\nexport const Track = SliderTrack;\nexport const Range = SliderRange;\nexport const Thumb = SliderThumb;","map":null,"metadata":{},"sourceType":"module"}