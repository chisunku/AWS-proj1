{"ast":null,"code":"import { useControllableState as e } from \"@radix-ui/react-use-controllable-state\";\nimport { useCallbackRef as o } from \"@radix-ui/react-use-callback-ref\";\nimport { Primitive as r } from \"@radix-ui/react-primitive\";\nimport { useId as t } from \"@radix-ui/react-id\";\nimport { createContextScope as n } from \"@radix-ui/react-context\";\nimport { useComposedRefs as i } from \"@radix-ui/react-compose-refs\";\nimport { createCollection as c } from \"@radix-ui/react-collection\";\nimport { composeEventHandlers as u } from \"@radix-ui/primitive\";\nimport * as s from \"react\";\nimport a from \"@babel/runtime/helpers/esm/extends\";\nconst f = {\n    bubbles: !1,\n    cancelable: !0\n  },\n  [p, l, m] = c(\"RovingFocusGroup\"),\n  [d, v] = n(\"RovingFocusGroup\", [m]);\nexport { v as createRovingFocusGroupScope };\nconst [g, F] = d(\"RovingFocusGroup\");\nexport const RovingFocusGroup = /*#__PURE__*/s.forwardRef((e, o) => /*#__PURE__*/s.createElement(p.Provider, {\n  scope: e.__scopeRovingFocusGroup\n}, /*#__PURE__*/s.createElement(p.Slot, {\n  scope: e.__scopeRovingFocusGroup\n}, /*#__PURE__*/s.createElement(w, a({}, e, {\n  ref: o\n}))))); /*#__PURE__*/\nconst w = /*#__PURE__*/s.forwardRef((t, n) => {\n  const {\n      __scopeRovingFocusGroup: c,\n      orientation: p,\n      dir: m = \"ltr\",\n      loop: d = !1,\n      currentTabStopId: v,\n      defaultCurrentTabStopId: F,\n      onCurrentTabStopIdChange: w,\n      onEntryFocus: b,\n      ...x\n    } = t,\n    E = s.useRef(null),\n    I = i(n, E),\n    [G = null, h] = e({\n      prop: v,\n      defaultProp: F,\n      onChange: w\n    }),\n    [T, A] = s.useState(!1),\n    y = o(b),\n    D = l(c),\n    S = s.useRef(!1);\n  return s.useEffect(() => {\n    const e = E.current;\n    if (e) return e.addEventListener(\"rovingFocusGroup.onEntryFocus\", y), () => e.removeEventListener(\"rovingFocusGroup.onEntryFocus\", y);\n  }, [y]), /*#__PURE__*/s.createElement(g, {\n    scope: c,\n    orientation: p,\n    dir: m,\n    loop: d,\n    currentTabStopId: G,\n    onItemFocus: s.useCallback(e => h(e), [h]),\n    onItemShiftTab: s.useCallback(() => A(!0), [])\n  }, /*#__PURE__*/s.createElement(r.div, a({\n    tabIndex: T ? -1 : 0,\n    \"data-orientation\": p\n  }, x, {\n    ref: I,\n    style: {\n      outline: \"none\",\n      ...t.style\n    },\n    onMouseDown: u(t.onMouseDown, () => {\n      S.current = !0;\n    }),\n    onFocus: u(t.onFocus, e => {\n      const o = !S.current;\n      if (e.target === e.currentTarget && o && !T) {\n        const o = new Event(\"rovingFocusGroup.onEntryFocus\", f);\n        if (e.currentTarget.dispatchEvent(o), !o.defaultPrevented) {\n          const e = D().filter(e => e.focusable);\n          R([e.find(e => e.active), e.find(e => e.id === G), ...e].filter(Boolean).map(e => e.ref.current));\n        }\n      }\n      S.current = !1;\n    }),\n    onBlur: u(t.onBlur, () => A(!1))\n  })));\n});\nexport const RovingFocusGroupItem = /*#__PURE__*/s.forwardRef((e, o) => {\n  const {\n      __scopeRovingFocusGroup: n,\n      focusable: i = !0,\n      active: c = !1,\n      ...f\n    } = e,\n    m = t(),\n    d = F(\"RovingFocusGroupItem\", n),\n    v = d.currentTabStopId === m,\n    g = l(n); /*#__PURE__*/\n  return s.createElement(p.ItemSlot, {\n    scope: n,\n    id: m,\n    focusable: i,\n    active: c\n  }, /*#__PURE__*/s.createElement(r.span, a({\n    tabIndex: v ? 0 : -1,\n    \"data-orientation\": d.orientation\n  }, f, {\n    ref: o,\n    onMouseDown: u(e.onMouseDown, e => {\n      i ? d.onItemFocus(m) : e.preventDefault();\n    }),\n    onFocus: u(e.onFocus, () => d.onItemFocus(m)),\n    onKeyDown: u(e.onKeyDown, e => {\n      if (\"Tab\" === e.key && e.shiftKey) return void d.onItemShiftTab();\n      if (e.target !== e.currentTarget) return;\n      const o = function (e, o, r) {\n        const t = function (e, o) {\n          return \"rtl\" !== o ? e : \"ArrowLeft\" === e ? \"ArrowRight\" : \"ArrowRight\" === e ? \"ArrowLeft\" : e;\n        }(e.key, r);\n        return \"vertical\" === o && [\"ArrowLeft\", \"ArrowRight\"].includes(t) || \"horizontal\" === o && [\"ArrowUp\", \"ArrowDown\"].includes(t) ? void 0 : b[t];\n      }(e, d.orientation, d.dir);\n      if (void 0 !== o) {\n        e.preventDefault();\n        let n = g().filter(e => e.focusable).map(e => e.ref.current);\n        if (\"last\" === o) n.reverse();else if (\"prev\" === o || \"next\" === o) {\n          \"prev\" === o && n.reverse();\n          const i = n.indexOf(e.currentTarget);\n          n = d.loop ? (t = i + 1, (r = n).map((e, o) => r[(t + o) % r.length])) : n.slice(i + 1);\n        }\n        setTimeout(() => R(n));\n      }\n      var r, t;\n    })\n  })));\n}); /*#__PURE__*/\nconst b = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction R(e) {\n  const o = document.activeElement;\n  for (const r of e) {\n    if (r === o) return;\n    if (r.focus(), document.activeElement !== o) return;\n  }\n}\nexport const Root = RovingFocusGroup;\nexport const Item = RovingFocusGroupItem;","map":null,"metadata":{},"sourceType":"module"}