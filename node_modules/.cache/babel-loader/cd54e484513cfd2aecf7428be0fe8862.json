{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect } from 'react';\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';\nimport { InterpreterStatus, State } from 'xstate';\nimport { useIdleInterpreter } from './useInterpret';\nfunction identity(a) {\n  return a;\n}\nexport function useMachine(getMachine) {\n  var _a = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    _a[_i - 1] = arguments[_i];\n  }\n  var _b = __read(_a, 1),\n    _c = _b[0],\n    options = _c === void 0 ? {} : _c;\n  // using `useIdleInterpreter` allows us to subscribe to the service *before* we start it\n  // so we don't miss any notifications\n  var service = useIdleInterpreter(getMachine, options);\n  var getSnapshot = useCallback(function () {\n    if (service.status === InterpreterStatus.NotStarted) {\n      return options.state ? State.create(options.state) : service.machine.initialState;\n    }\n    return service.state;\n  }, [service]);\n  var isEqual = useCallback(function (prevState, nextState) {\n    if (service.status === InterpreterStatus.NotStarted) {\n      return true;\n    }\n    // Only change the current state if:\n    // - the incoming state is the \"live\" initial state (since it might have new actors)\n    // - OR the incoming state actually changed.\n    //\n    // The \"live\" initial state will have .changed === undefined.\n    var initialStateChanged = nextState.changed === undefined && (Object.keys(nextState.children).length > 0 || typeof prevState.changed === 'boolean');\n    return !(nextState.changed || initialStateChanged);\n  }, [service]);\n  var subscribe = useCallback(function (handleStoreChange) {\n    var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;\n    return unsubscribe;\n  }, [service]);\n  var storeSnapshot = useSyncExternalStoreWithSelector(subscribe, getSnapshot, getSnapshot, identity, isEqual);\n  useEffect(function () {\n    var rehydratedState = options.state;\n    service.start(rehydratedState ? State.create(rehydratedState) : undefined);\n    return function () {\n      service.stop();\n      service.status = InterpreterStatus.NotStarted;\n    };\n  }, []);\n  return [storeSnapshot, service.send, service];\n}","map":null,"metadata":{},"sourceType":"module"}