{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { SimpleJwksCache, isJwk, isJwks, fetchJwk, assertIsRsaSignatureJwk, findJwkInJwks } from \"./jwk.js\";\nimport { assertIsNotPromise, assertStringArrayContainsString, assertStringEquals } from \"./assert.js\";\nimport { supportedSignatureAlgorithms } from \"./jwt-model.js\";\nimport { decomposeJwt, validateJwtFields } from \"./jwt.js\";\nimport { JwtInvalidClaimError, JwtInvalidIssuerError, JwtInvalidSignatureAlgorithmError, JwtInvalidSignatureError, KidNotFoundInJwksError, ParameterValidationError } from \"./error.js\";\nimport { nodeWebCompat } from \"#node-web-compat\";\n/**\n * Sanity check the JWT header and the selected JWK\n *\n * @param header: the JWT header (decoded and JSON parsed)\n * @param jwk: the JWK\n */\nfunction validateJwtHeaderAndJwk(header, jwk) {\n  // Check that the JWK is in fact a JWK for RSA signatures\n  assertIsRsaSignatureJwk(jwk);\n  // Check that JWT signature algorithm matches JWK\n  if (jwk.alg) {\n    assertStringEquals(\"JWT signature algorithm\", header.alg, jwk.alg, JwtInvalidSignatureAlgorithmError);\n  }\n  // Check JWT signature algorithm is one of the supported signature algorithms\n  assertStringArrayContainsString(\"JWT signature algorithm\", header.alg, supportedSignatureAlgorithms, JwtInvalidSignatureAlgorithmError);\n}\n/**\n * Verify a JWT asynchronously (thus allowing for the JWKS to be fetched from the JWKS URI)\n *\n * @param jwt The JWT\n * @param jwksUri The JWKS URI, where the JWKS can be fetched from\n * @param options Verification options\n * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects\n */\nexport async function verifyJwt(jwt, jwksUri, options) {\n  return verifyDecomposedJwt(decomposeJwt(jwt), jwksUri, options);\n}\n/**\n * Verify (asynchronously) a JWT that is already decomposed (by function `decomposeJwt`)\n *\n * @param decomposedJwt The decomposed JWT\n * @param jwksUri The JWKS URI, where the JWKS can be fetched from\n * @param options Verification options\n * @param jwkFetcher A function that can execute the fetch of the JWKS from the JWKS URI\n * @param transformJwkToKeyObjectFn A function that can transform a JWK into a crypto native key object\n * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects\n */\nasync function verifyDecomposedJwt(decomposedJwt, jwksUri, options) {\n  let jwkFetcher = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fetchJwk;\n  let transformJwkToKeyObjectFn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : nodeWebCompat.transformJwkToKeyObjectAsync;\n  const {\n    header,\n    headerB64,\n    payload,\n    payloadB64,\n    signatureB64\n  } = decomposedJwt;\n  const jwk = await jwkFetcher(jwksUri, decomposedJwt);\n  validateJwtHeaderAndJwk(decomposedJwt.header, jwk);\n  // Transform the JWK to native key format, that can be used with verifySignature\n  const keyObject = await transformJwkToKeyObjectFn(jwk, header.alg, payload.iss, header.kid);\n  // Verify the JWT signature\n  const valid = await nodeWebCompat.verifySignatureAsync({\n    jwsSigningInput: `${headerB64}.${payloadB64}`,\n    signature: signatureB64,\n    alg: header.alg,\n    keyObject\n  });\n  if (!valid) {\n    throw new JwtInvalidSignatureError(\"Invalid signature\");\n  }\n  try {\n    validateJwtFields(payload, options);\n    if (options.customJwtCheck) {\n      await options.customJwtCheck({\n        header,\n        payload,\n        jwk\n      });\n    }\n  } catch (err) {\n    if (options.includeRawJwtInErrors && err instanceof JwtInvalidClaimError) {\n      throw err.withRawJwt(decomposedJwt);\n    }\n    throw err;\n  }\n  return payload;\n}\n/**\n * Verify a JWT synchronously, using a JWKS or JWK that has already been fetched\n *\n * @param jwt The JWT\n * @param jwkOrJwks The JWKS that includes the right JWK (indexed by kid). Alternatively, provide the right JWK directly\n * @param options Verification options\n * @param transformJwkToKeyObjectFn A function that can transform a JWK into a crypto native key object\n * @returns The (JSON parsed) payload of the JWT––if the JWT is valid, otherwise an error is thrown\n */\nexport function verifyJwtSync(jwt, jwkOrJwks, options) {\n  let transformJwkToKeyObjectFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : nodeWebCompat.transformJwkToKeyObjectSync;\n  return verifyDecomposedJwtSync(decomposeJwt(jwt), jwkOrJwks, options, transformJwkToKeyObjectFn);\n}\n/**\n * Verify (synchronously) a JWT that is already decomposed (by function `decomposeJwt`)\n *\n * @param decomposedJwt The decomposed JWT\n * @param jwkOrJwks The JWKS that includes the right JWK (indexed by kid). Alternatively, provide the right JWK directly\n * @param options Verification options\n * @param transformJwkToKeyObjectFn A function that can transform a JWK into a crypto native key object\n * @returns The (JSON parsed) payload of the JWT––if the JWT is valid, otherwise an error is thrown\n */\nfunction verifyDecomposedJwtSync(decomposedJwt, jwkOrJwks, options, transformJwkToKeyObjectFn) {\n  const {\n    header,\n    headerB64,\n    payload,\n    payloadB64,\n    signatureB64\n  } = decomposedJwt;\n  let jwk;\n  if (isJwk(jwkOrJwks)) {\n    jwk = jwkOrJwks;\n  } else if (isJwks(jwkOrJwks)) {\n    const locatedJwk = header.kid ? findJwkInJwks(jwkOrJwks, header.kid) : undefined;\n    if (!locatedJwk) {\n      throw new KidNotFoundInJwksError(`JWK for kid ${header.kid} not found in the JWKS`);\n    }\n    jwk = locatedJwk;\n  } else {\n    throw new ParameterValidationError([`Expected a valid JWK or JWKS (parsed as JavaScript object), but received: ${jwkOrJwks}.`, \"If you're passing a JWKS URI, use the async verify() method instead, it will download and parse the JWKS for you\"].join());\n  }\n  validateJwtHeaderAndJwk(decomposedJwt.header, jwk);\n  // Transform the JWK to native key format, that can be used with verifySignature\n  const keyObject = transformJwkToKeyObjectFn(jwk, header.alg, payload.iss, header.kid);\n  // Verify the JWT signature (JWS)\n  const valid = nodeWebCompat.verifySignatureSync({\n    jwsSigningInput: `${headerB64}.${payloadB64}`,\n    signature: signatureB64,\n    alg: header.alg,\n    keyObject\n  });\n  if (!valid) {\n    throw new JwtInvalidSignatureError(\"Invalid signature\");\n  }\n  try {\n    validateJwtFields(payload, options);\n    if (options.customJwtCheck) {\n      const res = options.customJwtCheck({\n        header,\n        payload,\n        jwk\n      });\n      assertIsNotPromise(res, () => new ParameterValidationError(\"Custom JWT checks must be synchronous but a promise was returned\"));\n    }\n  } catch (err) {\n    if (options.includeRawJwtInErrors && err instanceof JwtInvalidClaimError) {\n      throw err.withRawJwt(decomposedJwt);\n    }\n    throw err;\n  }\n  return payload;\n}\n/**\n * Abstract class representing a verifier for JWTs signed with RSA (e.g. RS256, RS384, RS512)\n *\n * A class is used, because there is state:\n * - The JWKS is fetched (downloaded) from the JWKS URI and cached in memory\n * - Verification properties at verifier level, are used as default options for individual verify calls\n *\n * When instantiating this class, relevant type parameters should be provided, for your concrete case:\n * @param StillToProvide The verification options that you want callers of verify to provide on individual verify calls\n * @param SpecificVerifyProperties The verification options that you'll use\n * @param IssuerConfig The issuer config that you'll use (config options are used as default verification options)\n * @param MultiIssuer Verify multiple issuers (true) or just a single one (false)\n */\nexport class JwtRsaVerifierBase {\n  constructor(verifyProperties) {\n    let jwksCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new SimpleJwksCache();\n    this.jwksCache = jwksCache;\n    this.issuersConfig = new Map();\n    this.publicKeyCache = new KeyObjectCache();\n    if (Array.isArray(verifyProperties)) {\n      if (!verifyProperties.length) {\n        throw new ParameterValidationError(\"Provide at least one issuer configuration\");\n      }\n      for (const prop of verifyProperties) {\n        if (this.issuersConfig.has(prop.issuer)) {\n          throw new ParameterValidationError(`issuer ${prop.issuer} supplied multiple times`);\n        }\n        this.issuersConfig.set(prop.issuer, this.withJwksUri(prop));\n      }\n    } else {\n      this.issuersConfig.set(verifyProperties.issuer, this.withJwksUri(verifyProperties));\n    }\n  }\n  get expectedIssuers() {\n    return Array.from(this.issuersConfig.keys());\n  }\n  getIssuerConfig(issuer) {\n    if (!issuer) {\n      if (this.issuersConfig.size !== 1) {\n        throw new ParameterValidationError(\"issuer must be provided\");\n      }\n      issuer = this.issuersConfig.keys().next().value;\n    }\n    const config = this.issuersConfig.get(issuer);\n    if (!config) {\n      throw new ParameterValidationError(`issuer not configured: ${issuer}`);\n    }\n    return config;\n  }\n  /**\n   * This method loads a JWKS that you provide, into the JWKS cache, so that it is\n   * available for JWT verification. Use this method to speed up the first JWT verification\n   * (when the JWKS would otherwise have to be downloaded from the JWKS uri), or to provide the JWKS\n   * in case the JwtVerifier does not have internet access to download the JWKS\n   *\n   * @param jwksThe JWKS\n   * @param issuer The issuer for which you want to cache the JWKS\n   *  Supply this field, if you instantiated the JwtVerifier with multiple issuers\n   * @returns void\n   */\n  cacheJwks() {\n    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {\n      _ref[_key] = arguments[_key];\n    }\n    let [jwks, issuer] = _ref;\n    const issuerConfig = this.getIssuerConfig(issuer);\n    this.jwksCache.addJwks(issuerConfig.jwksUri, jwks);\n    this.publicKeyCache.clearCache(issuerConfig.issuer);\n  }\n  /**\n   * Hydrate the JWKS cache for (all of) the configured issuer(s).\n   * This will fetch and cache the latest and greatest JWKS for concerned issuer(s).\n   *\n   * @param issuer The issuer to fetch the JWKS for\n   * @returns void\n   */\n  async hydrate() {\n    const jwksFetches = this.expectedIssuers.map(issuer => this.getIssuerConfig(issuer).jwksUri).map(jwksUri => this.jwksCache.getJwks(jwksUri));\n    await Promise.all(jwksFetches);\n  }\n  /**\n   * Verify (synchronously) a JWT that is signed using RS256 / RS384 / RS512.\n   *\n   * @param jwt The JWT, as string\n   * @param props Verification properties\n   * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown\n   */\n  verifySync() {\n    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      _ref2[_key2] = arguments[_key2];\n    }\n    let [jwt, properties] = _ref2;\n    const {\n      decomposedJwt,\n      jwksUri,\n      verifyProperties\n    } = this.getVerifyParameters(jwt, properties);\n    return this.verifyDecomposedJwtSync(decomposedJwt, jwksUri, verifyProperties);\n  }\n  /**\n   * Verify (synchronously) an already decomposed JWT, that is signed using RS256 / RS384 / RS512.\n   *\n   * @param decomposedJwt The decomposed Jwt\n   * @param jwk The JWK to verify the JWTs signature with\n   * @param verifyProperties The properties to use for verification\n   * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown\n   */\n  verifyDecomposedJwtSync(decomposedJwt, jwksUri, verifyProperties) {\n    const jwk = this.jwksCache.getCachedJwk(jwksUri, decomposedJwt);\n    return verifyDecomposedJwtSync(decomposedJwt, jwk, verifyProperties, this.publicKeyCache.transformJwkToKeyObjectSync.bind(this.publicKeyCache));\n  }\n  /**\n   * Verify (asynchronously) a JWT that is signed using RS256 / RS384 / RS512.\n   * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,\n   * in case it is not yet available in the cache.\n   *\n   * @param jwt The JWT, as string\n   * @param props Verification properties\n   * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects\n   */\n  async verify() {\n    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      _ref3[_key3] = arguments[_key3];\n    }\n    let [jwt, properties] = _ref3;\n    const {\n      decomposedJwt,\n      jwksUri,\n      verifyProperties\n    } = this.getVerifyParameters(jwt, properties);\n    return this.verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties);\n  }\n  /**\n   * Verify (asynchronously) an already decomposed JWT, that is signed using RS256 / RS384 / RS512.\n   *\n   * @param decomposedJwt The decomposed Jwt\n   * @param jwk The JWK to verify the JWTs signature with\n   * @param verifyProperties The properties to use for verification\n   * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown\n   */\n  verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties) {\n    return verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties, this.jwksCache.getJwk.bind(this.jwksCache), this.publicKeyCache.transformJwkToKeyObjectAsync.bind(this.publicKeyCache));\n  }\n  /**\n   * Get the verification parameters to use, by merging the issuer configuration,\n   * with the overriding properties that are now provided\n   *\n   * @param jwt: the JWT that is going to be verified\n   * @param verifyProperties: the overriding properties, that override the issuer configuration\n   * @returns The merged verification parameters\n   */\n  getVerifyParameters(jwt, verifyProperties) {\n    const decomposedJwt = decomposeJwt(jwt);\n    assertStringArrayContainsString(\"Issuer\", decomposedJwt.payload.iss, this.expectedIssuers, JwtInvalidIssuerError);\n    const issuerConfig = this.getIssuerConfig(decomposedJwt.payload.iss);\n    return {\n      decomposedJwt,\n      jwksUri: issuerConfig.jwksUri,\n      verifyProperties: {\n        ...issuerConfig,\n        ...verifyProperties\n      }\n    };\n  }\n  /**\n   * Get issuer config with JWKS URI, by adding a default JWKS URI if needed\n   *\n   * @param config: the issuer config.\n   * @returns The config with JWKS URI\n   */\n  withJwksUri(config) {\n    if (config.jwksUri) {\n      return config;\n    }\n    const issuerUri = new URL(config.issuer).pathname.replace(/\\/$/, \"\");\n    return {\n      jwksUri: new URL(`${issuerUri}/.well-known/jwks.json`, config.issuer).href,\n      ...config\n    };\n  }\n}\n/**\n * Class representing a verifier for JWTs signed with RSA (e.g. RS256 / RS384 / RS512)\n */\nexport class JwtRsaVerifier extends JwtRsaVerifierBase {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  static create(verifyProperties, additionalProperties) {\n    return new this(verifyProperties, additionalProperties?.jwksCache);\n  }\n}\n/**\n * Class representing a cache of RSA public keys in native key object format\n *\n * Because it takes a bit of compute time to turn a JWK into native key object format,\n * we want to cache this computation.\n */\nexport class KeyObjectCache {\n  constructor() {\n    let transformJwkToKeyObjectSyncFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : nodeWebCompat.transformJwkToKeyObjectSync;\n    let transformJwkToKeyObjectAsyncFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nodeWebCompat.transformJwkToKeyObjectAsync;\n    this.transformJwkToKeyObjectSyncFn = transformJwkToKeyObjectSyncFn;\n    this.transformJwkToKeyObjectAsyncFn = transformJwkToKeyObjectAsyncFn;\n    this.publicKeys = new Map();\n  }\n  /**\n   * Transform the JWK into an RSA public key in native key object format.\n   * If the transformed JWK is already in the cache, it is returned from the cache instead.\n   * The cache keys are: issuer, JWK kid (key id)\n   *\n   * @param jwk: the JWK\n   * @param issuer: the issuer that uses the JWK for signing JWTs\n   * @returns the RSA public key in native key object format\n   */\n  transformJwkToKeyObjectSync(jwk, issuer) {\n    if (!issuer || !jwk.kid) {\n      return this.transformJwkToKeyObjectSyncFn(jwk);\n    }\n    const fromCache = this.publicKeys.get(issuer)?.get(jwk.kid);\n    if (fromCache) return fromCache;\n    const publicKey = this.transformJwkToKeyObjectSyncFn(jwk);\n    this.putKeyObjectInCache(jwk, issuer, publicKey);\n    return publicKey;\n  }\n  async transformJwkToKeyObjectAsync(jwk, issuer) {\n    if (!issuer || !jwk.kid) {\n      return this.transformJwkToKeyObjectAsyncFn(jwk);\n    }\n    const fromCache = this.publicKeys.get(issuer)?.get(jwk.kid);\n    if (fromCache) return fromCache;\n    const publicKey = await this.transformJwkToKeyObjectAsyncFn(jwk);\n    this.putKeyObjectInCache(jwk, issuer, publicKey);\n    return publicKey;\n  }\n  putKeyObjectInCache(jwk, issuer, publicKey) {\n    const cachedIssuer = this.publicKeys.get(issuer);\n    if (cachedIssuer) {\n      cachedIssuer.set(jwk.kid, publicKey);\n    } else {\n      this.publicKeys.set(issuer, new Map([[jwk.kid, publicKey]]));\n    }\n  }\n  clearCache(issuer) {\n    this.publicKeys.delete(issuer);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}